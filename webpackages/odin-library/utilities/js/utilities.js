'use strict';

/*
 * @namespace Utilities
 *
 * @class odin
 *
 * A global object, that contains all ODIN library utilities.
 */
var odin = {};

/*
 * @namespace Utilities
 * @class odin
 * @section
 * @function triggerOnViewUpdate(comp : ODIN component)
 * @aka odin.triggerOnViewUpdate
 *
 * Triggers the **onViewUpdate** output slot for `ODIN components` (views only) and
 * passes a `View update object` to it.
 */
odin.triggerOnViewUpdate = function (comp) {
	/*
	 * @namespace Misc
	 * @class View update object
	 * The definition of an view update object generated by `odin.triggerOnViewUpdate`.
	 * This object should only be used, if a view component wants to signal an update.
	 */
	comp.setOnViewUpdate({
		// @property componentName : String
		// The name of the `ODIN component`.
		componentName: comp.is,
		// @property id : Number
		// An unique identifier for the view update.
		id: Math.random()
	});
}

/*
 * @namespace Utilities
 * @class odin
 * @section
 * @function createErrorObj(comp : ODIN component, msg : String, cause? : Error|String) : Error object
 * @aka odin.createErrorObj
 *
 * Creates an `Error object`. The `cause` may be any error-like object with a
 * `message` property or a string.
 */
odin.createErrorObj = function (comp, msg, cause) {
	console.error('Error in "' + comp.is + '": ' + msg);
	if (cause) {
		console.error(cause);
		if (cause.message) {
			cause = cause.message;
		} else if (!odin.check.isString(cause)) {
			cause = undefined;
		}
	}
	/*
	 * @namespace Misc
	 * @class Error object
	 * The definition of an error object generated by `odin.createErrorObj`.
	 */
	return {
		// @property componentName : String
		// The name of the `ODIN component`, which had an error.
		componentName: comp.is,
		// @property message : String
		// A description of the error.
		message: msg,
		// @property cause : String|undefined
		// A description of why the error happened.
		cause: cause
	};
}

/*
 * @namespace Utilities
 * @class odin
 * @section
 * @function copyObject(src : Object, filter? : Function, transform? : Function) : Object
 * @aka odin.copyObject
 *
 * Creates a shallow copy of the given object. `filter` can be used to define which properties
 * should be transferred (the function must return `true` if the property should be included,
 * otherwise `false`). `transform` may be used to alternate the property value of the source
 * object and transfer the alternation instead (useful if one wants to copy an object deeply).
 * Both, `filter` and `transform` functions, will receive three parameters: the key as string,
 * the property value and the source object.
 *
 * <p>**Example:**
 * <pre><code class="lang-javascript">var mySrcObj = { first: 'foo', second: null };
 * var copy = odin.copyObject(mySrcObj, function (key, value, src) {
 * 	// omit 'empty' properties
 * 	return value !== undefined && value !== null;
 * }, function (key, value, src) {
 * 	// add something to every string
 * 	return odin.check.isString(value) ? value + 'bar' : value;
 * });
 * console.log(copy); // prints: { first: 'foobar' }</code></pre>
 * </p>
 */
odin.copyObject = function (src, filter, transform) {
	if (!filter) {
		filter = function (k, v, o) {
			return true;
		};
	}
	var result = {};
	for (var key in src) {
		var value = src[key];
		if (src.hasOwnProperty(key) && filter(key, value, src)) {
			result[key] = transform ? transform(key, value, src) : value;
		}
	}
	return result;
}

/*
 * @function objectToArray(src : Object, toIndexMapper? : Function) : Array
 * @aka odin.objectToArray
 *
 * Transforms an object to an array. `toIndexMapper` may be used to define
 * the index of a certain property. The function will receive three parameters:
 * the key as string, the property value and the source object. If a position shall
 * be defined by the algorithm (add to the current last position of the array),
 * the function must return `undefined`. In all other cases the function defines
 * the position by returning an array index. If this position is occupied, then the
 * algorithm will overwrite the value at this position. Depending of how the function
 * is implemented, the resulting array may contain `undefined` positions. If
 * `toIndexMapper` is not defined, it would be like a function which returns always
 * `undefined`. The order of the elements in the resulting array is not guaranteed
 * by the algorithm.
 *
 * <p>**Example:**
 * <pre><code class="lang-javascript">var obj = { first: 'foo', second: null };
 * var array = odin.objectToArray(obj, function (key, value, src) {
 * 	// 'first' should be at position 0, 'second' should be at position 2
 * 	return key === 'first' ? 0 : (key === 'second' ? 2 : undefined);
 * });
 * console.log(array); // prints: [ 'foo', undefined, null ]</code></pre>
 * </p>
 */
odin.objectToArray = function (src, toIndexMapper) {
	var result = [];
	if (toIndexMapper) {
		for (var key in src) {
			if (src.hasOwnProperty(key)) {
				var value = src[key];
				var index = toIndexMapper(key, value, src);
				if (index) {
					result[index] = value;
				} else {
					result.push(value);
				}
			}
		}
	} else {
		for (var key in src) {
			if (src.hasOwnProperty(key)) {
				var value = src[key];
				result.push(value);
			}
		}
	}
	return result;
}

/*
 * @function arrayToObject(src : Array, toKeyMapper? : Function) : Object
 * @aka odin.arrayToObject
 *
 * Transforms an array to an object. `toKeyMapper` may be used to define
 * the property keys of a certain element. The function will receive three parameters:
 * the element, the index and the source object. If a position (or element) should
 * be omitted, the function must return `undefined`. In all other cases the function
 * defines the property key by returning a string. If this key is occupied, then the
 * algorithm will overwrite the property value for this key. If `toKeyMapper` is not
 * defined, it would be like a function which returns the index of the element as key.
 *
 * <p>**Example:**
 * <pre><code class="lang-javascript">var array = [ 'foo', undefined, null ];
 * var obj = odin.objectToArray(array, function (elem, idx, src) {
 * 	// position 0 should be 'first', position 2 should be 'second'
 * 	return idx === 0 ? 'first' ? (idx === 2 ? 'second' : undefined);
 * });
 * console.log(obj); // prints: { first: 'foo', second: null }</code></pre>
 * </p>
 */
odin.arrayToObject = function (src, toKeyMapper) {
	if (!toKeyMapper) {
		toKeyMapper = function (elem, idx, src) {
			return '' + idx;
		};
	}
	var result = {};
	for (var i = 0; i < src.length; i++) {
		var e = src[i];
		var key = toKeyMapper(e, i, src);
		if (key !== undefined) {
			result[key] = e;
		}
	}
	return result;
}

/*
 * @function mergeArrays(first : Array, second : Array) : Array
 * @aka odin.mergeArrays
 *
 * Combines two array into a new array. Elements that are present in both arrays
 * won't appear twice in the new array. The comparison is based on `===`.
 *
 * <p>**Example:**
 * <pre><code class="lang-javascript">var first = [ 'foo', 1 ];
 * var second = [ 'foo', 2 ];
 * var merged = odin.mergeArrays(first, second);
 * console.log(merged); // prints: [ 'foo', 1, 2 ]</code></pre>
 * </p>
 */
odin.mergeArrays = function (first, second) {
	var result = [];
	first.forEach(function (e) {
		result.push(e);
	});
	second.forEach(function (e) {
		if (result.indexOf(e) < 0) {
			result.push(e);
		}
	});
	return result;
}

/*
 * @function mergeObjects(first : Object, second : Object) : Object
 * @aka odin.mergeObjects
 *
 * Combines two objects into a new object. Property keys that are present in both
 * objects don't overwrite each others property value. Instead, the property value
 * of `first` will be given a higher priority.
 *
 * <p>**Example:**
 * <pre><code class="lang-javascript">var first = { foo: 'bar', bar: 2 };
 * var second = { foo: 'foo', foo: 1 };
 * var merged = odin.mergeObjects(first, second);
 * console.log(merged); // prints: { foo: 'bar', foo: 1, bar: 2 }</code></pre>
 * </p>
 */
odin.mergeObjects = function (first, second) {
	var result = {};
	for (var key in second) {
		if (second.hasOwnProperty(key)) {
			result[key] = second[key];
		}
	}
	for (var key in first) {
		if (first.hasOwnProperty(key)) {
			result[key] = first[key];
		}
	}
	return result;
}

/*
 * @function getObjectValues(obj : Object) : Array
 * @aka odin.getObjectValues
 *
 * Puts every property value of an object in a new array. The order of the
 * elements in the resulting array is not guaranteed by the algorithm.
 */
odin.getObjectValues = function (obj) {
	var result = [];
	for (var key in obj) {
		if (obj.hasOwnProperty(key)) {
			result.push(obj[key]);
		}
	}
	return result;
}

/*
 * @class odin.check
 * @aka odin.ckeck
 *
 * A global object, that contains useful functions for type checking.
 */
odin.check = {};

/*
 * @function isBoolean(value : *) : Boolean
 * @aka odin.check.isBoolean
 *
 * Checks if the given value is a primitive boolean or an object Boolean (prototype).
 * Returns `true`, if the check was successful, otherwise `false`.
 */
odin.check.isBoolean = function (value) {
	switch (typeof value) {
	case 'boolean':
		return true;
	case 'object':
		return value instanceof Boolean;
	default:
		return false;
	}
};

/*
 * @function isNumber(value : *) : Boolean
 * @aka odin.check.isNumber
 *
 * Checks if the given value is a primitive number or an object Number (prototype).
 * Returns `true`, if the check was successful, otherwise `false`.
 */
odin.check.isNumber = function (value) {
	switch (typeof value) {
	case 'number':
		return true;
	case 'object':
		return value instanceof Number;
	default:
		return false;
	}
};

/*
 * @function isString(value : *) : Boolean
 * @aka odin.check.isString
 *
 * Checks if the given value is a primitive string or an object String (prototype).
 * Returns `true`, if the check was successful, otherwise `false`.
 */
odin.check.isString = function (value) {
	switch (typeof value) {
	case 'string':
		return true;
	case 'object':
		return value instanceof String;
	default:
		return false;
	}
};

/*
 * @class odin.parse
 * @aka odin.parse
 *
 * A global object, that contains useful functions for type parsing.
 */
odin.parse = {};

/*
 * @function toBoolean(value : *) : Boolean
 * @aka odin.parse.toBoolean
 *
 * Parses a given value to a primitive boolean. Type checks include
 * primitive and object checks.
 *
 * <p><table class="table table-hover table-bordered table-sm">
 * 	<thead class="thead-dark">
 * 		<th scope="col" style="white-space:nowrap;">value type</th>
 * 		<th scope="col" style="white-space:nowrap;">conversion test</th>
 * 		<th scope="col" style="white-space:nowrap;">parsing result</th>
 * 	</thead>
 * 	<tbody>
 * 		<tr>
 * 			<td>String</td>
 * 			<td>`value === 'true'`</td>
 * 			<td>test is `true` &rarr; returns `true`, otherwise `false`</td>
 * 		</tr>
 * 		<tr>
 * 			<td>Number</td>
 * 			<td>`value === 1`</td>
 * 			<td>test is `true` &rarr; returns `true`, otherwise `false`</td>
 * 		</tr>
 * 		<tr>
 * 			<td>Boolean</td>
 * 			<td></td>
 * 			<td>returns a primitive version of `value`</td>
 * 		</tr>
 * 		<tr>
 * 			<td>Any other type</td>
 * 			<td></td>
 * 			<td>returns `false`</td>
 * 		</tr>
 * 	</tbody>
 * </table></p>
 */
odin.parse.toBoolean = function (value) {
	switch (typeof value) {
	case 'string':
		return value === 'true' ? true : false;
	case 'number':
		return value === 1 ? true : false;
	case 'boolean':
		return value;
	case 'object':
		if (value instanceof Boolean) {
			return value.valueOf();
		} else if (value instanceof Number) {
			return value.valueOf() === 1 ? true : false;
		} else if (value instanceof String) {
			return value.valueOf() === 'true' ? true : false;
		} else {
			return false;
		}
	default:
		return false;
	}
}

odin.parse.isNumberRE = new RegExp('^-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?$');

/*
 * @function toNumber(value : *) : Number
 * @aka odin.parse.toNumber
 *
 * Parses a given value to a primitive number. Type checks include
 * primitive and object checks.
 *
 * <p><table class="table table-hover table-bordered table-sm">
 * 	<thead class="thead-dark">
 * 		<th scope="col" style="white-space:nowrap;">value type</th>
 * 		<th scope="col" style="white-space:nowrap;">conversion test</th>
 * 		<th scope="col" style="white-space:nowrap;">parsing result</th>
 * 	</thead>
 * 	<tbody>
 * 		<tr>
 * 			<td>String</td>
 * 			<td>A strict test based of the syntax of
 * 				<a href="https://tools.ietf.org/html/rfc7159#section-6">JSON numbers</a></td>
 * 			<td>test is `true` &rarr; parses the string with `parseFloat(value)` and
 * 				returns the number, otherwise `NaN`</td>
 * 		</tr>
 * 		<tr>
 * 			<td>Number</td>
 * 			<td></td>
 * 			<td>returns a primitive version of `value`</td>
 * 		</tr>
 * 		<tr>
 * 			<td>Boolean</td>
 * 			<td>`value === true`</td>
 * 			<td>test is `true` &rarr; returns `1`, otherwise `0`</td>
 * 		</tr>
 * 		<tr>
 * 			<td>Any other type</td>
 * 			<td></td>
 * 			<td>returns `NaN`</td>
 * 		</tr>
 * 	</tbody>
 * </table></p>
 */
odin.parse.toNumber = function (value) {
	switch (typeof value) {
	case 'string':
		return odin.parse.isNumberRE.test(value) ? parseFloat(value) : NaN;
	case 'number':
		return value;
	case 'boolean':
		return value ? 1 : 0;
	case 'object':
		if (value instanceof Boolean) {
			return value.valueOf() ? 1 : 0;
		} else if (value instanceof Number) {
			return value.valueOf();
		} else if (value instanceof String) {
			return odin.parse.isNumberRE.test(value) ? parseFloat(value) : NaN;
		} else {
			return NaN;
		}
	default:
		return NaN;
	}
}

/*
 * @function toString(value : *) : String
 * @aka odin.parse.toString
 *
 * Parses a given value to a primitive string. Type checks include
 * primitive and object checks.
 *
 * <p><table class="table table-hover table-bordered table-sm">
 * 	<thead class="thead-dark">
 * 		<th scope="col" style="white-space:nowrap;">value type</th>
 * 		<th scope="col" style="white-space:nowrap;">parsing result</th>
 * 	</thead>
 * 	<tbody>
 * 		<tr>
 * 			<td>String</td>
 * 			<td>returns a primitive version of `value`</td>
 * 		</tr>
 * 		<tr>
 * 			<td>Number</td>
 * 			<td>returns `value.toString()`</td>
 * 		</tr>
 * 		<tr>
 * 			<td>Boolean</td>
 * 			<td>returns `value.toString()`</td>
 * 		</tr>
 * 		<tr>
 * 			<td>Any other type</td>
 * 			<td>returns an empty string</td>
 * 		</tr>
 * 	</tbody>
 * </table></p>
 */
odin.parse.toString = function (value) {
	switch (typeof value) {
	case 'string':
		return value;
	case 'number':
		return '' + value;
	case 'boolean':
		return '' + value;
	case 'object':
		if (value instanceof Boolean) {
			return value.toString();
		} else if (value instanceof Number) {
			return value.toString();
		} else if (value instanceof String) {
			return value.valueOf();
		} else {
			return '';
		}
	default:
		return '';
	}
}

/*
 * @class odin.validate
 * @aka odin.validate
 *
 * A global object, that contains useful functions and properties for validation tasks.
 *
 * <p>**TODO** in den components erwähnen dass json schema usw. genutzt wird</p>
 */
odin.validate = {};

/*
 * @class odin.validate.schema
 * @aka odin.validate.schema
 * @aka Json Schema
 *
 * A property of `odin.validate`, which contains common Json Schemata. All
 * schemata are based on <a href="http://json-schema.org/">Draft-06</a>.
 */
odin.validate.schema = {};

/*
 * @property dataObjectTupels : Json Schema
 * @aka odin.validate.schema.dataObjectTupels
 *
 * A `Json Schema` that one can use to validate a value according to the definition
 * of a **Array with object tupels** data structure (see `normalized data structure`).
 */
odin.validate.schema.dataObjectTupels = {
	'$schema': 'http://json-schema.org/draft-06/schema#',
	'type': 'array',
	'items': {
		'type': 'object'
	}
};

/*
 * @property dataObjectSeries : Json Schema
 * @aka odin.validate.schema.dataObjectSeries
 *
 * A `Json Schema` that one can use to validate a value according to the definition
 * of a **Object with series per property** data structure (see `normalized data structure`).
 * Equality-length check of the property values is not covered by this schema.
 */
odin.validate.schema.dataObjectSeries = {
	'$schema': 'http://json-schema.org/draft-06/schema#',
	'type': 'object',
	'patternProperties': {
		'^.*$': {
			'type': 'array'
		}
	}
};

/*
 * @property dataArrays : Json Schema
 * @aka odin.validate.schema.dataArrays
 *
 * A `Json Schema` that one can use to validate a value according to the definition
 * of a **Array with array tupels** and **Array with array series** data structures (see
 * `normalized data structure`). Equality-length check of the sub-arrays is not covered
 * by this schema.
 */
odin.validate.schema.dataArrays = {
	'$schema': 'http://json-schema.org/draft-06/schema#',
	'type': 'array',
	'items': {
		'type': 'array'
	}
};

/*
 * @property geojson : Json Schema
 * @aka odin.validate.schema.geojson
 *
 * A `Json Schema` that one can use to validate a value according to the definition
 * of the <a href="https://tools.ietf.org/html/rfc7946">RFC 7946: The GeoJSON Format</a>.
 */
odin.validate.schema.geojson = {
	'$schema': 'http://json-schema.org/draft-06/schema#',
	'title': 'GeoJSON schema based on RFC 7946',
	'definitions': {
		'position': {
			'type': 'array',
			'minItems': 2,
			'items': [{
					'type': 'number'
				}, {
					'type': 'number'
				}
			],
			'additionalItems': true
		},
		'positionArray': {
			'type': 'array',
			'items': {
				'$ref': '#/definitions/position'
			}
		},
		'lineString': {
			'allOf': [{
					'$ref': '#/definitions/positionArray'
				}, {
					'minItems': 2
				}
			]
		},
		'polygon': {
			'type': 'array',
			'items': {
				'allOf': [{
						'$ref': '#/definitions/positionArray'
					}, {
						'minItems': 4
					}
				]
			}
		},
		'GeoJSONObject': {
			'type': 'object',
			'properties': {
				'bbox': {
					'type': 'array',
					'items': {
						'type': 'number'
					},
					'oneOf': [{
							'minItems': 4,
							'maxItems': 4
						}, {
							'minItems': 6,
							'maxItems': 6
						}
					]
				}
			}
		},
		'GeometryObject': {
			'allOf': [{
					'$ref': '#/definitions/GeoJSONObject'
				}, {
					'required': ['type'],
					'oneOf': [{
							'required': ['coordinates'],
							'properties': {
								'type': {
									'const': 'Point'
								},
								'coordinates': {
									'$ref': '#/definitions/position'
								}
							}
						}, {
							'required': ['coordinates'],
							'properties': {
								'type': {
									'const': 'MultiPoint'
								},
								'coordinates': {
									'$ref': '#/definitions/positionArray'
								}
							}
						}, {
							'required': ['coordinates'],
							'properties': {
								'type': {
									'const': 'LineString'
								},
								'coordinates': {
									'$ref': '#/definitions/lineString'
								}
							}
						}, {
							'required': ['coordinates'],
							'properties': {
								'type': {
									'const': 'MultiLineString'
								},
								'coordinates': {
									'type': 'array',
									'items': {
										'$ref': '#/definitions/lineString'
									}
								}
							}
						}, {
							'required': ['coordinates'],
							'properties': {
								'type': {
									'const': 'Polygon'
								},
								'coordinates': {
									'$ref': '#/definitions/polygon'
								}
							}
						}, {
							'required': ['coordinates'],
							'properties': {
								'type': {
									'const': 'MultiPolygon'
								},
								'coordinates': {
									'type': 'array',
									'items': {
										'$ref': '#/definitions/polygon'
									}
								}
							}
						}, {
							'required': ['geometries'],
							'properties': {
								'type': {
									'const': 'GeometryCollection'
								},
								'geometries': {
									'type': 'array',
									'items': {
										'$ref': '#/definitions/GeometryObject'
									}
								}
							}
						}
					],
					'not': {
						'anyOf': [{
								'required': ['geometry'],
							}, {
								'required': ['properties'],
							}, {
								'required': ['features'],
							}
						]
					}
				}
			]
		},
		'FeatureObject': {
			'allOf': [{
					'$ref': '#/definitions/GeoJSONObject'
				}, {
					'required': ['type', 'geometry', 'properties'],
					'properties': {
						'type': {
							'const': 'Feature'
						},
						'geometry': {
							'oneOf': [{
									'$ref': '#/definitions/GeometryObject'
								}, {
									'type': 'null'
								}
							]
						},
						'properties': {
							'type': ['object', 'null']
						},
						'id': {
							'type': ['string', 'number']
						}
					},
					'not': {
						'anyOf': [{
								'required': ['coordinates'],
							}, {
								'required': ['geometries'],
							}, {
								'required': ['features'],
							}
						]
					}
				}
			]
		},
		'FeatureCollection': {
			'allOf': [{
					'$ref': '#/definitions/GeoJSONObject'
				}, {
					'type': 'object',
					'required': ['type', 'features'],
					'properties': {
						'type': {
							'const': 'FeatureCollection'
						},
						'features': {
							'type': 'array',
							'items': {
								'$ref': '#/definitions/FeatureObject'
							}
						}
					},
					'not': {
						'anyOf': [{
								'required': ['coordinates'],
							}, {
								'required': ['geometries'],
							}, {
								'required': ['geometry'],
							}, {
								'required': ['properties'],
							}
						]
					}
				}
			]

		}
	},
	'oneOf': [{
			'$ref': '#/definitions/GeometryObject'
		}, {
			'$ref': '#/definitions/FeatureObject'
		}, {
			'$ref': '#/definitions/FeatureCollection'
		}
	]
};

/*
 * @class odin.validate.schemaPart
 * @aka odin.validate.schemaPart
 * @aka Json Schema Part
 *
 * A property of `odin.validate`, which contains common Json Schemata Parts.
 * Parts are validation rule definitions that can be used in a JavaScript context
 * to replace common rules in a schema (meaning: less code).
 */
odin.validate.schemaPart = {};

odin.validate.schemaPart.constTrue = {
	'const': true
};

odin.validate.schemaPart.constFalse = {
	'const': false
};

// @section for Strings

odin.validate.schemaPart.string = {
	'type': 'string'
};

/*
 * @property stringEmptyDefault : Json Schema Part
 * @aka odin.validate.schemaPart.stringEmptyDefault
 *
 * Defines a rule with the type string and an empty string as default.
 */
odin.validate.schemaPart.stringEmptyDefault = {
	'type': 'string',
	'default': ''
};

/*
 * @property minString : Json Schema Part
 * @aka odin.validate.schemaPart.minString
 *
 * Defines a rule with the type string and a minimum length of `1`.
 */
odin.validate.schemaPart.minString = {
	'type': 'string',
	'minLength': 1
};

/*
 * @property urlString : Json Schema Part
 * @aka odin.validate.schemaPart.urlString
 *
 * Defines a rule with the type string and a format `url` (see
 * <a href="https://github.com/epoberezkin/ajv#formats">here</a> for more information).
 */
odin.validate.schemaPart.urlString = {
	'type': 'string',
	'format': 'url'
};

/*
 * @property uriTemplateString : Json Schema Part
 * @aka odin.validate.schemaPart.uriTemplateString
 *
 * Defines a rule with the type string and a format `uri-template` (see
 * <a href="https://github.com/epoberezkin/ajv#formats">here</a> for more information).
 */
odin.validate.schemaPart.uriTemplateString = {
	'type': 'string',
	'format': 'uri-template'
};

/*
 * @property jsonPointerString : Json Schema Part
 * @aka odin.validate.schemaPart.jsonPointerString
 *
 * Defines a rule with the type string and a format `json-pointer` (see
 * <a href="https://github.com/epoberezkin/ajv#formats">here</a> for more information).
 */
odin.validate.schemaPart.jsonPointerString = {
	'type': 'string',
	'format': 'json-pointer'
};

/*
 * @property notJsonPointerString : Json Schema Part
 * @aka odin.validate.schemaPart.notJsonPointerString
 *
 * Defines a rule with the type string, a minimum length of `1` and is not a valid
 * `json-pointer` (see <a href="https://github.com/epoberezkin/ajv#formats">here</a>
 * for more information).
 */
odin.validate.schemaPart.notJsonPointerString = {
	'allOf': [odin.validate.schemaPart.minString, {
			'not': {
				'format': 'json-pointer'
			}
		}
	]
};

/*
 * @property hexColor : Json Schema Part
 * @aka odin.validate.schemaPart.hexColor
 *
 * Defines a rule with the type string and a pattern to check if the string is a
 * hexadecimal notation of a web color. Notation syntax is based on
 * <a href="https://drafts.csswg.org/css-color/#hex-notation">CSS Color Module Level 4 (Draft)</a>.
 */
odin.validate.schemaPart.hexColor = {
	'type': 'string',
	'pattern': '^#(([A-Fa-f0-9]{2}){2,4}|[A-Fa-f0-9]{3})$'
};

/*
 * @property rgbColor : Json Schema Part
 * @aka odin.validate.schemaPart.rgbColor
 *
 * Defines a rule with the type string and a pattern to check if the string is a
 * functional notation (rgb/rgba) of a web color. Notation syntax is based on
 * <a href="https://drafts.csswg.org/css-color/#rgb-functions">CSS Color Module Level 4 (Draft)</a>.
 */
odin.validate.schemaPart.rgbColor = {
	'type': 'string',
	'pattern': '^rgba?\\(\\s*((((25[0-5]|2[0-4]\\d|1(\\d){2}|\\d\\d?)\\s*,\\s*){2}(25[0-5]|2[0-4]\\d|1(\\d){2}|\\d\\d?)\\s*(,\\s*((1|0?\\.\\d+)|(100|\\d\\d?)%))?)|(((100|\\d\\d?)%\\s*,\\s*){2}(100|\\d\\d?)%\\s*(,\\s*((1|0?\\.\\d+)|(100|\\d\\d?)%))?)|(((25[0-5]|2[0-4]\\d|1(\\d){2}|\\d\\d?)\\s+){2}(25[0-5]|2[0-4]\\d|1(\\d){2}|\\d\\d?)\\s*(\\/\\s*((1|0?\\.\\d+)|(100|\\d\\d?)%))?)|(((100|\\d\\d?)%\\s+){2}(100|\\d\\d?)%\\s*(\\/\\s*((1|0?\\.\\d+)|(100|\\d\\d?)%))?))\\s*\\)$'
};

/*
 * @property hslColor : Json Schema Part
 * @aka odin.validate.schemaPart.hslColor
 *
 * Defines a rule with the type string and a pattern to check if the string is a
 * functional notation (hsl/hsla) of a web color. Notation syntax is based on
 * <a href="https://drafts.csswg.org/css-color/#the-hsl-notation">CSS Color Module Level 4 (Draft)</a>.
 */
odin.validate.schemaPart.hslColor = {
	'type': 'string',
	'pattern': '^hsla?\\(\\s*(((((3[0-6]\\d|[1-2]\\d{2}|\\d\\d?)(deg)?)|((400|[1-3]\\d{2}|\\d\\d?)grad)|((\\d+(\\.\\d+)?)rad)|((1|0?\\.\\d+)turn))\\s*,\\s*(100|\\d\\d?)%\\s*,\\s*(100|\\d\\d?)%\\s*(,\\s*((1|0?\\.\\d+)|(100|\\d\\d?)%))?)|((((3[0-6]\\d|[1-2]\\d{2}|\\d\\d?)(deg)?)|((400|[1-3]\\d{2}|\\d\\d?)grad)|((\\d+(\\.\\d+)?)rad)|((1|0?\\.\\d+)turn))\\s+(100|\\d\\d?)%\\s+(100|\\d\\d?)%\\s*(\\/\\s*((1|0?\\.\\d+)|(100|\\d\\d?)%))?))\\s*\\)$'
};

/*
 * @property htmlColor : Json Schema Part
 * @aka odin.validate.schemaPart.htmlColor
 *
 * Defines a rule with the type string and one of the web color definitions: `hexColor`, `rgbColor`,
 * `hslColor`, a string containing only alpha characters (for the color keywords) or
 * one of the strings `transparent` or `currentcolor`. Notation syntax and other definitions
 * are based on <a href="https://drafts.csswg.org/css-color/#the-hsl-notation">CSS Color Module
 * Level 4 (Draft)</a>.
 */
odin.validate.schemaPart.htmlColor = {
	'anyOf': [odin.validate.schemaPart.hexColor, odin.validate.schemaPart.rgbColor, odin.validate.schemaPart.hslColor, {
			'type': 'string',
			'pattern': '^[a-zA-Z]+$'
		}, {
			'enum': ['transparent', 'currentcolor']
		}
	]
};

// @section for Numbers

odin.validate.schemaPart.number = {
	'type': 'number'
};

/*
 * @property positiveNumber : Json Schema Part
 * @aka odin.validate.schemaPart.positiveNumber
 *
 * Defines a rule with the type number and an exclusiveMinimum of `0`.
 */
odin.validate.schemaPart.positiveNumber = {
	'type': 'number',
	'exclusiveMinimum': 0
};

/*
 * @property zeroPositiveNumber : Json Schema Part
 * @aka odin.validate.schemaPart.zeroPositiveNumber
 *
 * Defines a rule with the type number and a minimum of `0`.
 */
odin.validate.schemaPart.zeroPositiveNumber = {
	'type': 'number',
	'minimum': 0
};

/*
 * @property negativeNumber : Json Schema Part
 * @aka odin.validate.schemaPart.negativeNumber
 *
 * Defines a rule with the type number and an exclusiveMaximum of `0`.
 */
odin.validate.schemaPart.negativeNumber = {
	'type': 'number',
	'exclusiveMaximum': 0
};

/*
 * @property zeroNegativeNumber : Json Schema Part
 * @aka odin.validate.schemaPart.zeroNegativeNumber
 *
 * Defines a rule with the type number and a maximum of `0`.
 */
odin.validate.schemaPart.zeroNegativeNumber = {
	'type': 'number',
	'maximum': 0
};

odin.validate.schemaPart.integer = {
	'type': 'integer'
};

/*
 * @property positiveInteger : Json Schema Part
 * @aka odin.validate.schemaPart.positiveInteger
 *
 * Defines a rule with the type integer and an exclusiveMinimum of `0`.
 */
odin.validate.schemaPart.positiveInteger = {
	'type': 'integer',
	'exclusiveMinimum': 0
};

/*
 * @property zeroPositiveInteger : Json Schema Part
 * @aka odin.validate.schemaPart.zeroPositiveInteger
 *
 * Defines a rule with the type integer and a minimum of `0`.
 */
odin.validate.schemaPart.zeroPositiveInteger = {
	'type': 'integer',
	'minimum': 0
};

/*
 * @property negativeInteger : Json Schema Part
 * @aka odin.validate.schemaPart.negativeInteger
 *
 * Defines a rule with the type integer and an exclusiveMaximum of `0`.
 */
odin.validate.schemaPart.negativeInteger = {
	'type': 'integer',
	'exclusiveMaximum': 0
};

/*
 * @property zeroNegativeInteger : Json Schema Part
 * @aka odin.validate.schemaPart.zeroNegativeInteger
 *
 * Defines a rule with the type integer and a maximum of `0`.
 */
odin.validate.schemaPart.zeroNegativeInteger = {
	'type': 'integer',
	'maximum': 0
};

/*
 * @property percent : Json Schema Part
 * @aka odin.validate.schemaPart.percent
 * @aka Percent
 *
 * Defines a rule with the type number, a minimum of `0` and a maximum of `1`.
 */
odin.validate.schemaPart.percent = {
	'type': 'number',
	'minimum': 0,
	'maximum': 1,
};

// @section for Booleans

odin.validate.schemaPart.boolean = {
	'type': 'boolean'
};

/*
 * @property booleanDefaultTrue : Json Schema Part
 * @aka odin.validate.schemaPart.booleanDefaultTrue
 *
 * Defines a rule with the type boolean and `true` as default.
 */
odin.validate.schemaPart.booleanDefaultTrue = {
	'type': 'boolean',
	'default': true
};

/*
 * @property booleanDefaultFalse : Json Schema Part
 * @aka odin.validate.schemaPart.booleanDefaultFalse
 *
 * Defines a rule with the type boolean and `false` as default.
 */
odin.validate.schemaPart.booleanDefaultFalse = {
	'type': 'boolean',
	'default': false
};

odin.validate.ajv = new Ajv({
		allErrors: true,
		verbose: true,
		jsonPointers: true,
		unknownFormats: [],
		useDefaults: true,
		formats: {
			// reg exp literal
			regExpLit: function (str) {
				if (!odin.check.isString(str)) {
					return false;
				}
				if (str.indexOf('/') !== 0) {
					return false;
				}
				var lastSolidus = str.lastIndexOf('/');
				if (lastSolidus === 0) {
					// error: syntax of regexp
					return false;
				}
				try {
					new RegExp(str.substring(1, lastSolidus), str.substring(lastSolidus + 1, str.length));
					return true;
				} catch (error) {
					// error: syntax of regexp
					return false;
				}
			},
			// not a reg exp literal
			notRegExpLit: function (str) {
				if (!odin.check.isString(str)) {
					return false;
				}
				if (str.indexOf('/') !== 0) {
					return true;
				}
				var lastSolidus = str.lastIndexOf('/');
				if (lastSolidus === 0) {
					// error: syntax of regexp
					return true;
				}
				try {
					new RegExp(str.substring(1, lastSolidus), str.substring(lastSolidus + 1, str.length));
					return false;
				} catch (error) {
					// error: syntax of regexp
					console.log('notRegExpLit', str);
					return true;
				}
			}
		},
		extendRefs: 'fail'
	});

/*
 * @class odin.validate
 * @section
 * @function withSchema(schema : Json Schema, data : *) : Errors|undefined
 * @aka odin.validate.withSchema
 *
 * Validates a value (`data`) based on a given `Json Schema`. Returns a collection of
 * validation errors if the validation fails, otherwise `undefined`. If the schema is
 * in itself flawed, then an error object will be returned.
 *
 * <p>**Example:**
 * <pre><code class="lang-javascript">var data = [ 'not a valid "Array with object tupels" data structure' ];
 * var schema = odin.validate.schema.dataObjectTupels;
 * var errors = odin.validate.withSchema(schema, data);
 * if (errors) {
 * 	console.error(errors);
 * 	return;
 * }</code></pre>
 *
 * </p><p>Uses <a href="http://epoberezkin.github.io/ajv/">ajv</a> as Json Schema validator.</p>
 */
odin.validate.withSchema = function (schema, data) {
	try {
		var validate = odin.validate.ajv.compile(schema);
		var valid = validate(data);
		// returns 'null' if valid
		var errors = validate.errors;
		return errors ? errors : undefined;
	} catch (err) {
		return err;
	}
}

/*
 * @class odin.path
 * @aka odin.path
 *
 * A global object, that contains functions and properties for handling
 * the ODIN path notation (`Path tokens` and `Path object`).
 */
odin.path = {};

odin.path.schemaPartAsArray = {
	'type': 'array',
	'uniqueItems': true,
	'items': {
		'oneOf': [{
				'type': 'string',
				'format': 'regExpLit'
			}, {
				'type': 'string',
				'format': 'notRegExpLit'
			}, odin.validate.schemaPart.zeroPositiveInteger
		]
	}
};

/*
 * @property schemaPart : Json Schema Part
 * @aka odin.path.schemaPart
 *
 * Defines a rule according the definition of `Path tokens` without
 * a parsing option (see `Odin Path w/o parsing`).
 */
odin.path.schemaPart = {
	'oneOf': [odin.validate.schemaPart.jsonPointerString, odin.path.schemaPartAsArray]
};

/*
 * @property schemaPartWithParse : Json Schema Part
 * @aka odin.path.schemaPartWithParse
 *
 * Defines a rule according the definition of `Path tokens` with an
 * optional parsing option (see `Odin Path w/ parsing`).
 */
odin.path.schemaPartWithParse = {
	'oneOf': [odin.path.schemaPart, {
			'type': 'object',
			'required': ['path', 'parse'],
			'properties': {
				'path': odin.path.schemaPart,
				'parse': {
					'enum': ['boolean', 'number', 'string', null]
				}
			}
		}
	]
};

odin.path.schemaPathTokens = {
	/*
	 * @namespace Misc
	 * @class Path tokens
	 *
	 * TODO
	 *
	 * <h4>Odin Path w/o parsing</h4>
	 * @aka Odin Path w/o parsing
	 *
	 * TODO
	 *
	 * <h4>Odin Path w/ parsing</h4>
	 * @aka Odin Path w/ parsing
	 *
	 * TODO
	 */
	'$schema': 'http://json-schema.org/draft-06/schema#',
	'allOf': [odin.path.schemaPartWithParse]
};

/*
 * @namespace Utilities
 * @class odin.path
 * @function isPathTokens(obj : *) : Boolean
 * @aka odin.path.isPathTokens
 *
 * `true` if the given parameter has the type `Path tokens`, otherwise `false`.
 */
odin.path.isPathTokens = function (obj) {
	return odin.validate.withSchema(odin.path.schemaPathTokens, obj) ? false : true;
}

odin.path.isZeroPositiveIntegerRE = new RegExp('^(?:0|[1-9]\\d*)$');

/*
 * @function create(pathTokens : Path tokens) : Path object
 * @aka odin.path.create
 *
 * Creates a `Path object` from the given `Path tokens`. This function may
 * throw errors.
 *
 * <p>**Errors:**
 * <table class="table table-hover table-bordered table-sm">
 * 	<thead class="thead-dark">
 * 		<th scope="col" style="white-space:nowrap;">Name</th>
 * 		<th scope="col" style="white-space:nowrap;">Condition</th>
 * 	</thead>
 * 	<tbody>
 * 		<tr>
 * 			<td>TODO</td>
 * 			<td>TODO</td>
 * 		</tr>
 * 	</tbody>
 * </table>
 * </p>
 */
odin.path.create = function (pathTokens) {
	var parseText = function (e) {
		var idx = odin.path.isZeroPositiveIntegerRE.test(e) ? parseInt(e, 10) : NaN;
		return isNaN(idx) ? e : idx;
	};
	var createPathFromArray = function (arr) {
		var path = [];
		for (var i = 0; i < arr.length; i++) {
			var e = arr[i];
			if (odin.check.isNumber(e)) {
				// array index as number
				path.push(e);
			} else if (odin.check.isString(e)) {
				// regexp, short check
				var firstSolidus = e.indexOf('/');
				var lastSolidus = e.lastIndexOf('/');
				if (firstSolidus === 0 && firstSolidus !== lastSolidus) {
					// a invalid regexp syntax could mean it's just text
					try {
						path.push(new RegExp(e.substring(1, lastSolidus), e.substring(lastSolidus + 1, e.length)));
					} catch (err) {
						// text or array index as text
						path.push(parseText(e));
					}
				} else {
					// text or array index as text
					path.push(parseText(e));
				}
			} else {
				// error: wrong type
				throw new Error('Unexpected type in odin path: ' + e);
			}
		}
		return path;
	};
	/*
	 * @namespace Misc
	 * @class Path object
	 *
	 * TODO
	 */
	var pathObj = {
		path: null
	};
	if (odin.check.isString(pathTokens)) {
		// json pointer
		pathObj.path = jsonPointer.parse(pathTokens);
	} else if (typeof pathTokens === 'object') {
		// array or object with 'parse' option
		if (Array.isArray(pathTokens)) {
			// array
			pathObj.path = createPathFromArray(pathTokens);
		} else {
			// object with 'parse' option
			if (odin.check.isString(pathTokens.path)) {
				// 'path' is json pointer
				pathObj.path = jsonPointer.parse(pathTokens.path);
			} else if (Array.isArray(pathTokens.path)) {
				// 'path is array
				pathObj.path = createPathFromArray(pathTokens.path);
			} else {
				// error: wrong structure
				throw new Error('Unexpected path tokens (no json pointer nor array with path tokens in object with "parse" option): ' + pathTokens);
			}
			// add 'parse' option
			pathObj.parse = pathTokens.parse;
		}
	} else {
		// error: wrong structure
		throw new Error('Unexpected path tokens (no json pointer, array with path tokens nor object with "parse" option): ' + pathTokens);
	}
	return pathObj;
}

/*
 * @namespace Utilities
 * @class odin.path
 * @function resolve(pathObj : Path object, obj : *) : *
 * @aka odin.path.resolve
 *
 * Extracts a value from a given value (`obj`) with the given
 * `Path object`. If a parsing option is specified, then TODO.
 * This function may throw errors.
 *
 * <p>**Errors:**
 * <table class="table table-hover table-bordered table-sm">
 * 	<thead class="thead-dark">
 * 		<th scope="col" style="white-space:nowrap;">Name</th>
 * 		<th scope="col" style="white-space:nowrap;">Condition</th>
 * 	</thead>
 * 	<tbody>
 * 		<tr>
 * 			<td>TODO</td>
 * 			<td>TODO</td>
 * 		</tr>
 * 	</tbody>
 * </table>
 * </p>
 */
odin.path.resolve = function (pathObj, obj) {
	var result = obj;
	for (var i = 0; i < pathObj.path.length; i++) {
		var e = pathObj.path[i];
		if (odin.check.isNumber(e)) {
			if (!Array.isArray(result)) {
				// error: not an array
				throw new Error('Path element "' + e + '" requires an array, but no array was found in:\n' + JSON.stringify(result, null, 2));
			}
			if (e < 0 || e >= result.length) {
				// error: out of bounds
				throw new Error('Path element "' + e + '" is out of bounds in:\n' + JSON.stringify(result, null, 2));
			}
			result = result[e];
		} else if (e instanceof RegExp) {
			if (typeof result !== 'object') {
				// error: not an object (no properties to match)
				throw new Error('Path element "' + e + '" requires an object, but no object was found in:\n' + JSON.stringify(result, null, 2));
			}
			var newResult = [];
			for (var prop in obj) {
				// order is not predictable, if more props matches it's an error condition
				e.lastIndex = 0;
				if (e.test(prop)) {
					newResult.push(obj[prop]);
				}
			}
			if (newResult.length === 0) {
				result = undefined;
			} else if (newResult.length > 1) {
				// error: more than one match found
				throw new Error('Path element "' + e + '" (RegExp) matches more than one property in:\n' + JSON.stringify(result, null, 2));
			} else {
				result = newResult[0];
			}
		} else if (odin.check.isString(e)) {
			if (typeof result !== 'object') {
				// error: not an object (no properties to match)
				throw new Error('Path element "' + e + '" requires an object, but no object was found in:\n' + JSON.stringify(result, null, 2));
			}
			result = result[e];
		} else {
			// error: unknown path type
			throw new Error('Path element "' + e + '" is not a string, RegExp or number.');
		}
		if (!result) {
			// not defined or null
			break;
		}
	}
	if (pathObj.parse !== undefined) {
		switch (pathObj.parse) {
		case 'number':
			result = odin.parse.toNumber(result);
			if (!isFinite(result)) {
				result = isNaN(result) ? 'NaN' : (result < 0 ? '-Infinity' : 'Infinity');
			}
			break;
		case 'boolean':
			result = odin.parse.toBoolean(result);
			break;
		case 'string':
			result = odin.parse.toString(result);
			break;
		case null:
			result = null;
			break;
		default:
			throw new Error('Unknown parse to type: ' + pathObj.parse);
		}
	}
	return result;
}
